<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
      xmlns:layout="http://www.ultraq.net.nz/web/thymeleaf/layout"
      layout:decorator="layout/defaultLayout">
<head>
    <title th:text="#{chart.label.chartList}"></title>
</head>
<body>
<th:block layout:fragment="content">
    <div class="chart-header">
        <div class="header-title flex-row align-items-baseline">
            <h1 th:text="#{chart.label.chartList}"></h1>
            <h6 class="description" th:text="#{chart.msg.searchDescription}"></h6>
        </div>
        <div class="header-search flex-row">
            <input type="hidden" sec:authorize="hasAuthority('chart.create') || hasAuthority('chart.update')"
                   th:name="isRole" th:value="true"/>
            <input type="hidden" sec:authorize="!hasAuthority('chart.create') && !hasAuthority('chart.update')"
                   th:name="isRole" th:value="false"/>
            <form id="searchFrm">
                <select id="searchTypeName" name="searchTypeName" class="col-3 mr-2">
                    <option value="" th:text="#{chart.label.all}" selected></option>
                    <option th:each="type:${typeList}" th:value="${type.codeValue}" th:text="${type.codeName}"></option>
                </select>
                <span id="spanTotalCount" class="txt-num"></span>
            </form>
            <div class="ml-auto">
                <button type="button" class="default-fill" sec:authorize="hasAuthority('chart.create')"
                        th:text="#{common.btn.add}" th:onclick="openChartEditModal()"></button>
            </div>
        </div>
    </div>
    <div class="chart-content flex-fill">
        <div class="list" id="chartList"></div>
    </div>
</th:block>
</body>
<th:block layout:fragment="pageScript">
    <script th:src="@{/assets/vendors/highCharts/highcharts.js}"></script>
    <script type="text/javascript">
        /*<![CDATA[*/
        let offsetCount = 0;
        const STATUS_SUCCESS = '0';
        const CHART_YEAR = 'Y';
        const CHART_MONTH = 'M';
        const CHART_DAY = 'D';
        const CHART_HOUR = 'H';
        const STACKED_COLUMN_CHART = 'chart.stackedColumn';
        const BASIC_LINE_CHART = 'chart.basicLine';

        window.onload = function () {
            document.getElementById('searchTypeName').addEventListener('change', function () {
                searchCharts(false);
            });
            searchCharts(false);
        }

        /**
         * Chart 검색
         */
        function searchCharts(isScroll) {
            let urlParam = '';
            if (isScroll) {
                if (offsetCount === 0) {
                    offsetCount = aliceJs.searchDataCount;
                }
                urlParam = aliceJs.serialize(document.getElementById('searchFrm')) + '&offset=' + offsetCount;
                restSearchSubmit('get', '/rest/charts?' + urlParam, isScroll);
            } else {
                offsetCount = 0;
                urlParam = aliceJs.serialize(document.getElementById('searchFrm')) + '&offset=' + offsetCount;
                restSearchSubmit('get', '/charts?' + urlParam, isScroll);
            }
        }

        /**
         * REST SEARCH API
         */
        function restSearchSubmit(method, url, isScroll) {
            const opt = {
                method: method,
                url: url,
                async: false,
                showProgressbar: false,
                callbackFunc: function (response) {
                    if (isScroll) {
                        let dataList = JSON.parse(response.responseText);
                        if (dataList.length > 0) {
                            aliceJs.showTotalCount(dataList[0].totalCount);
                            document.getElementById('totalCount').value = dataList[0].totalCount;
                            if (aliceJs.isEnableScrollEvent(offsetCount)) {
                                offsetCount = offsetCount + aliceJs.searchDataCount;
                                dataList.forEach(function (data) {
                                    getDataTemplate(data);
                                });
                            }
                        }
                    } else {
                        document.getElementById('chartList').innerHTML = response.responseText;
                        aliceJs.showTotalCount(document.getElementById('totalCount').value);
                        let chartDtEle = document.querySelectorAll('td[name=chartDt]');
                        for (let i = 0; i < chartDtEle.length; i++) {
                            chartDtEle[i].textContent = i18n.userDateTime(chartDtEle[i].textContent);
                        }
                    }

                    OverlayScrollbars(document.querySelector('.list-body'), {
                        className: 'scrollbar',
                        callbacks: {
                            onScroll: function (e) {
                                const scrollHeight = e.target.scrollHeight;
                                const scrollTop = e.target.scrollTop;
                                const clientHeight = e.target.clientHeight;
                                if (scrollHeight - scrollTop === clientHeight) {
                                    if (aliceJs.isEnableScrollEvent(offsetCount)) {
                                        searchCharts(true);
                                    }
                                }
                            }
                        }
                    });
                }
            };
            aliceJs.sendXhr(opt);
        }

        /**
         * REST API
         */
        function restSubmit(method, url, data, result, isShowProgressbar) {
            const opt = {
                method: method,
                url: url,
                params: JSON.stringify(data),
                contentType: 'application/json',
                callbackFunc: function (response) {
                    result(response.responseText);
                },
                showProgressbar: isShowProgressbar
            };
            aliceJs.sendXhr(opt);
        }

        /**
         * Tr 동적 데이터 만들기
         */
        function getDataTemplate(data) {
            let div = document.querySelector('.list-body .os-content');
            let tr = document.createElement('tr');
            tr.className = 'flex-row align-items-center';

            let tdChartType = document.createElement('td');
            tdChartType.style.width = '15%';
            tdChartType.className = 'align-left';
            tdChartType.innerText = i18n.msg(data.chartType);

            let tdChartName = document.createElement('td');
            tdChartName.style.width = '15%';
            tdChartName.className = 'align-left underline point-fill pointer';
            tdChartName.innerText = data.chartName;
            if (document.getElementsByName('isRole')[0].value === 'true') {
                tdChartName.onclick = function () {
                    openChartViewModal(data.chartId);
                }
            }

            let tdChartDesc = document.createElement('td');
            tdChartDesc.style.width = '25%';
            tdChartDesc.className = 'align-left';
            tdChartDesc.innerText = data.chartDesc;

            let tdChartEdit = document.createElement('td');
            tdChartEdit.style.width = '10%';
            tdChartEdit.className = 'align-center';
            tdChartEdit.innerText = '';

            if (document.getElementsByName('isRole')[0].value === 'true') {
                let btnChartEdit = document.createElement('button');
                let spanChartEdit = document.createElement('span');
                spanChartEdit.className = 'icon-edit';
                btnChartEdit.appendChild(spanChartEdit);
                btnChartEdit.onclick = function () {
                    openChartEditModal(data.chartId);
                }
                tdChartEdit.appendChild(btnChartEdit);
            }

            let tdChartCreateUserName = document.createElement('td');
            tdChartCreateUserName.style.width = '15%';
            tdChartCreateUserName.className = 'align-left';
            tdChartCreateUserName.innerText = data.createUserName;

            let tdChartCreateDt = document.createElement('td');
            tdChartCreateDt.style.width = '20%';
            tdChartCreateDt.className = 'align-left';
            tdChartCreateDt.innerText = i18n.userDateTime(data.createDt);

            tr.appendChild(tdChartType);
            tr.appendChild(tdChartName);
            tr.appendChild(tdChartDesc);
            tr.appendChild(tdChartEdit);
            tr.appendChild(tdChartCreateUserName);
            tr.appendChild(tdChartCreateDt);
            div.appendChild(tr);
        }

        /**
         * Chart edit 화면 호출 (Modal)
         */
        function openChartEditModal(chartId) {
            let chartOptions = {
                title: i18n.msg('chart.label.edit'),
                body: createModalContent('edit'),
                classes: 'chart-edit-modal',
                buttons: [
                    // 미리보기
                    {
                        content: i18n.msg('chart.btn.preview'),
                        classes: "default-fill",
                        bindKey: false,
                        callback: function (modal) {
                        }
                    }],
                close: {
                    closable: false,
                },
                onCreate: function (modal) {
                    OverlayScrollbars(document.querySelector('.modal-content'), {className: 'scrollbar'});
                    getChart(chartId);
                }
            };

            if (chartId !== undefined) {
                chartOptions.buttons.push({
                    content: i18n.msg('common.btn.delete'),
                    classes: "default-fill",
                    bindKey: false,
                    callback: function (modal) {
                        deleteChart(chartId);
                    }
                });
            }

            chartOptions.buttons.push({
                content: (chartId !== undefined) ? i18n.msg('common.btn.save') : i18n.msg('common.btn.register'),
                classes: "point-fill",
                bindKey: false,
                callback: function (modal) {
                    let method = (chartId !== undefined) ? 'put' : 'post'
                    saveChart(method, chartId)
                }
            });

            chartOptions.buttons.push({
                content: i18n.msg('common.btn.cancel'),
                classes: "default-line",
                bindKey: false,
                callback: function (modal) {
                    modal.hide();
                }
            });

            const chartEditModal = new modal(chartOptions);
            chartEditModal.show();
        }

        /**
         * Chart view 화면 호출 (Modal)
         */
        function openChartViewModal(chartId) {
            let chartOptions = {
                classes: 'chart-edit-modal',
                buttons: [{
                    content: i18n.msg('common.btn.cancel'),
                    classes: "default-line",
                    bindKey: false,
                    callback: function (modal) {
                        modal.hide();
                    }
                }],
                close: {
                    closable: false,
                },
                onCreate: function (modal) {
                }
            };

            const chartViewModal = new modal(chartOptions);
            chartViewModal.show();
        }

        function createModalContent() {
            return `<div class="flex-column" id="getChart"><div>`
        }

        function getChart(chartId) {
            let strUrl = ''
            if (chartId === undefined) {
                strUrl = '/charts/new';
            } else {
                strUrl = '/charts/' + chartId + '/edit';
            }

            const opt = {
                method: 'get',
                url: strUrl,
                contentType: 'application/json',
                showProgressbar: false,
                callbackFunc: function (response) {
                    document.getElementById('getChart').innerHTML = response.responseText;
                    setDisplay(document.getElementById('typeSelectBox').value);
                    let data = parsedPropertyJson(document.getElementById('chartConfig').value, document.getElementById('propertyJson').value);
                    Highcharts.chart('container', {
                        chart: data.chart,
                        title: data.title,
                        tooltip: data.tooltip,
                        accessibility: data.accessibility,
                        plotOptions: data.plotOptions,
                        series: data.series
                    });
                }
            };
            aliceJs.sendXhr(opt);
        }

        function emptyValidataion() {
            if (isEmpty('chartName', 'chart.msg.enterChartName')) {
                return false
            }
            if (isEmpty('targetLabel', 'chart.msg.enterTargetLabel')) {
                return false
            }
            if (isEmpty('durationDigit', 'chart.msg.enterDurationDigit')) {
                return false
            }
            return true;
        }

        /**
         * chart 저장 / 수정
         */
        function saveChart(method, chartId) {
            if (emptyValidataion()) {
                let chartInfo = {
                    chartType: document.getElementById('typeSelectBox').value,
                    chartName: document.getElementById('chartName').value,
                    chartDesc: document.getElementById('chartDesc').value,
                    targetLabel: document.getElementById('targetLabel').value,
                    operation: document.getElementById('operationSelectBox').value,
                    durationDigit: document.getElementById('durationDigit').value,
                    durationUnit: document.getElementById('durationUnitSelectBox').value
                }

                if (chartInfo.chartType === STACKED_COLUMN_CHART || chartInfo.chartType === BASIC_LINE_CHART) {
                    chartInfo.periodUnit = document.getElementById('periodUnitSelectBox').value;

                    switch (chartInfo.durationUnit) {
                        case CHART_MONTH:
                            if (chartInfo.periodUnit === CHART_YEAR) {
                                aliceJs.alertDanger(i18n.msg('chart.msg.periodUnitOutOfRange'));
                                return false;
                            }
                            break;
                        case CHART_DAY:
                            if (chartInfo.periodUnit === CHART_YEAR || chartInfo.periodUnit === CHART_MONTH) {
                                aliceJs.alertDanger(i18n.msg('chart.msg.periodUnitOutOfRange'));
                                return false;
                            }
                            break;
                        case CHART_HOUR:
                            if (chartInfo.periodUnit === CHART_YEAR || chartInfo.periodUnit === CHART_MONTH || chartInfo.periodUnit === CHART_DAY) {
                                aliceJs.alertDanger(i18n.msg('chart.msg.periodUnitOutOfRange'));
                                return false;
                            }
                            break;
                    }

                    if (chartInfo.chartType === BASIC_LINE_CHART) {
                        chartInfo.group = document.getElementById('targetGroup').value;
                    }
                }

                let url = '/rest/charts';
                if (method === 'put' && chartId !== undefined) {
                    chartInfo.chartId = chartId;
                    url += '/' + chartId;
                }
                restSubmit(method, url, chartInfo, function (result) {
                    switch (result) {
                        case STATUS_SUCCESS:
                            aliceJs.alertSuccess(i18n.msg('common.msg.save'), function () {
                                location.reload()
                            });
                            break;
                        default:
                            aliceJs.alertDanger(i18n.msg('common.msg.fail'));
                            break;
                    }
                })
            }
        }

        /**
         * chart 삭제
         */
        function deleteChart(chartId) {
            aliceJs.confirmIcon(i18n.msg('common.msg.confirmDelete'), restSubmit, null, 'delete', '/rest/charts/' +
                chartId, {}, function (result) {
                switch (result) {
                    case STATUS_SUCCESS:
                        aliceJs.alertSuccess('[[#{common.msg.delete}]]', function () {
                            location.reload();
                        });
                        break;
                    default:
                        aliceJs.alertDanger(i18n.msg('common.msg.fail'));
                        break;
                }
            })
        }

        function onlyNumber(event) {
            event = event || window.event;
            const keyID = (event.which) ? event.which : event.keyCode;
            if (!((keyID >= 48 && keyID <= 57) || (keyID >= 96 && keyID <= 105)
                || keyID === 8 || keyID === 9 || keyID === 46 || keyID === 37 || keyID === 39)) {
                return false;
            }
        }

        function removeChar(event) {
            event = event || window.event;
            const keyID = (event.which) ? event.which : event.keyCode;
            if (!(keyID === 8 || keyID === 9 || keyID === 46 || keyID === 37 || keyID === 39)) {
                event.target.value = event.target.value.replace(/[^0-9]/g, '');
            }
        }

        function setDisplay(value) {
            if (value === 'chart.basicLine' || value === 'chart.stackedColumn') {
                document.getElementById('periodUnitLabel').style.display = 'block';
                document.getElementById('periodUnitSelectBox').style.display = 'block';
                if (value === 'chart.basicLine') {
                    document.getElementById('groupLabel').style.display = 'block';
                    document.getElementById('targetGroup').style.display = 'block';
                } else {
                    document.getElementById('groupLabel').style.display = 'none';
                    document.getElementById('targetGroup').style.display = 'none';
                }
            } else {
                document.getElementById('periodUnitLabel').style.display = 'none';
                document.getElementById('periodUnitSelectBox').style.display = 'none';
                document.getElementById('groupLabel').style.display = 'none';
                document.getElementById('targetGroup').style.display = 'none';
            }
        }

        /** chartConfig 파싱 진행 **/
        function parsedPropertyJson(chartConfig, property) {
            let chartConfigJson = JSON.parse(chartConfig);
            let propertyJson = JSON.parse(property);
            let jsonObject = new Object();

            // get chartConfigJson Data
            let type = chartConfigJson.type;
            let operation = chartConfigJson.operation;
            let durationDigit = chartConfigJson.duration.digit;
            let durationUnit = chartConfigJson.duration.unit;

            // get propertyJson Data
            let countArray = new Array;
            let percentArray = new Array;
            for (key in propertyJson[0].operation) {
                // 문서에 대한 카운트 개수
                countArray.push(propertyJson[0].operation[key].count);
                // 문서에 대한 각 퍼센트
                percentArray.push(propertyJson[0].operation[key].percent);
            }

            let docKeyList = new Array;
            let docValueList = new Array;
            for (key in propertyJson[1].documentList) {
                // 문서의 각 나눈 연도의 개수
                docKeyList.push(key);
                // 문서가 가진 정보 값 documentId, documentName, createDt
                docValueList.push(propertyJson[1].documentList[key]);
            }

            // chart
            let chartProperty = new Object();
            chartProperty.type = chartConfigJson.type.substring(6, chartConfigJson.type.length);
            chartProperty.plotBackgroundColor = null;
            chartProperty.plotBorderWidth = null;
            chartProperty.plotShadow = false;
            jsonObject.chart = chartProperty;

            // title
            let titleProperty = new Object;
            titleProperty.text = propertyJson[0].title;
            jsonObject.title = titleProperty;

            // tooltip
            let tooltipProperty = new Object;
            if (chartConfigJson.operation === 'percent') {
                tooltipProperty.pointFormat = '문서 차지 비율: <b>{point.percentage:.1f} %</b>';
            } else {
                tooltipProperty.pointFormat = '문서 건 수: <b>{point.y:.f} 건</b>';
            }
            jsonObject.tooltip = tooltipProperty;

            // accessibility
            let accessibilityProperty = new Object;
            let pointProperty = new Object;
            pointProperty.valueSuffix = '%';
            accessibilityProperty.point = pointProperty
            jsonObject.accessibility = accessibilityProperty;

            // plotOptions
            let plotOptionsProperty = new Object;
            let pieProperty = new Object;
            let dataLabelsProperty = new Object;
            pieProperty.allowPoinSelect = true;
            pieProperty.cursor = 'pointer';
            dataLabelsProperty.enabled = true;
            if (chartConfigJson.operation === 'percent') {
                dataLabelsProperty.format = '<b>{point.name}</b>: {point.percentage:.1f} %';
            } else {
                dataLabelsProperty.format = '<b>{point.name}</b>: {y:.f} 건';
            }
            pieProperty.dataLabels = dataLabelsProperty;
            plotOptionsProperty.pie = pieProperty;
            jsonObject.plotOptions = plotOptionsProperty;

            // series
            let seriesArray = new Array;
            let seriesObject = new Object;
            let seriesDataArray = new Array;
            seriesObject.colorByPoint = true;

            for (let i = 0; i < Object.keys(propertyJson[1].documentList).length; i++) {
                let seriesDataObject = new Object;
                seriesDataObject.name = docKeyList[i];
                seriesDataObject.y = countArray[i];
                seriesDataObject.sliced = true;
                seriesDataObject.selected = true;
                seriesDataArray.push(seriesDataObject);
            }
            seriesObject.data = seriesDataArray;
            seriesArray.push(seriesObject);
            jsonObject.series = seriesArray;

            console.log(jsonObject);
            return jsonObject;
        }

        /*]]>*/
    </script>
</th:block>
</html>
