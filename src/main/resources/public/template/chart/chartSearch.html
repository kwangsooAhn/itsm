<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security"
      xmlns:layout="http://www.ultraq.net.nz/web/thymeleaf/layout"
      layout:decorator="layout/defaultLayout">
<head>
    <title th:text="#{chart.label.chartList}"></title>
</head>
<body>
<th:block layout:fragment="content">
    <div class="chart-header">
        <div class="header-title flex-row align-items-baseline">
            <h1 th:text="#{chart.label.chartList}"></h1>
            <h6 class="description" th:text="#{chart.msg.searchDescription}"></h6>
        </div>
        <div class="header-search flex-row">
            <input type="hidden" sec:authorize="hasAuthority('chart.create') || hasAuthority('chart.update')"
                   th:name="isRole" th:value="true"/>
            <input type="hidden" sec:authorize="!hasAuthority('chart.create') && !hasAuthority('chart.update')"
                   th:name="isRole" th:value="false"/>
            <form id="searchFrm">
                <select id="searchTypeName" name="searchTypeName" class="col-3 mr-2">
                    <option value="" th:text="#{chart.label.all}" selected></option>
                    <option th:each="type:${typeList}" th:value="${type.codeValue}" th:text="${type.codeName}"></option>
                </select>
                <span id="spanTotalCount" class="txt-num"></span>
            </form>
            <div class="ml-auto">
                <button type="button" class="default-fill" sec:authorize="hasAuthority('chart.create')"
                        th:text="#{common.btn.add}" th:onclick="openChartEditModal()"></button>
            </div>
        </div>
    </div>
    <div class="chart-content flex-fill">
        <div class="list" id="chartList"></div>
    </div>
</th:block>
</body>
<th:block layout:fragment="pageScript">
    <script th:src="@{/assets/vendors/highCharts/highcharts.js}"></script>
    <script type="text/javascript">
        /*<![CDATA[*/
        let offsetCount = 0;
        const STATUS_SUCCESS = '0';
        const CHART_YEAR = 'Y';
        const CHART_MONTH = 'M';
        const CHART_DAY = 'D';
        const CHART_HOUR = 'H';
        const PIE_CHART = 'chart.pie';
        const STACKED_COLUMN_CHART = 'chart.stackedColumn';
        const BASIC_LINE_CHART = 'chart.basicLine';

        window.onload = function () {
            document.getElementById('searchTypeName').addEventListener('change', function () {
                searchCharts(false);
            });
            searchCharts(false);
        }

        /**
         * Chart 검색
         */
        function searchCharts(isScroll) {
            let urlParam = '';
            if (isScroll) {
                if (offsetCount === 0) {
                    offsetCount = aliceJs.searchDataCount;
                }
            } else {
                offsetCount = 0;
            }
            urlParam = aliceJs.serialize(document.getElementById('searchFrm')) + '&offset=' + offsetCount + '&isScroll=' + isScroll;
            restSearchSubmit('get', '/charts?' + urlParam, isScroll);
        }

        /**
         * REST SEARCH API
         */
        function restSearchSubmit(method, url, isScroll) {
            const opt = {
                method: method,
                url: url,
                async: false,
                showProgressbar: false,
                callbackFunc: function (response) {
                    if (isScroll) {
                        if (aliceJs.isEnableScrollEvent(offsetCount)) {
                            offsetCount = offsetCount + aliceJs.searchDataCount;
                        }
                        const chartTbody = document.querySelector('.list-body .os-content');
                        const tempTb = document.createElement('table');
                        tempTb.innerHTML = response.responseText;
                        setDateTimeFormat(tempTb);
                        for (let i = 0; i < tempTb.rows.length; i++) {
                            chartTbody.appendChild(tempTb.rows[i]);
                        }
                    } else {
                        document.getElementById('chartList').innerHTML = response.responseText;
                        aliceJs.showTotalCount(document.getElementById('totalCount').value);
                        setDateTimeFormat(document.getElementById('chartList'));
                        OverlayScrollbars(document.querySelector('.list-body'), {
                            className: 'scrollbar',
                            callbacks: {
                                onScroll: function (e) {
                                    const scrollHeight = e.target.scrollHeight;
                                    const scrollTop = e.target.scrollTop;
                                    const clientHeight = e.target.clientHeight;
                                    if (scrollHeight - scrollTop === clientHeight) {
                                        if (aliceJs.isEnableScrollEvent(offsetCount)) {
                                            searchCharts(true);
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            };
            aliceJs.sendXhr(opt);
        }

        /**
         * REST API
         */
        function restSubmit(method, url, data, result, isShowProgressbar) {
            const opt = {
                method: method,
                url: url,
                params: JSON.stringify(data),
                contentType: 'application/json',
                callbackFunc: function (response) {
                    result(response.responseText);
                },
                showProgressbar: isShowProgressbar
            };
            aliceJs.sendXhr(opt);
        }

        /**
         * 서버에서 전달받은 데이터의 날짜 포맷을 변경한다.
         */
        function setDateTimeFormat(elem) {
            elem.querySelectorAll('.date-time').forEach(dt => {
                dt.textContent = i18n.userDateTime(dt.textContent.trim());
            });
        }

        /**
         * Chart edit 화면 호출 (Modal)
         */
        function openChartEditModal(chartId) {
            let chartOptions = {
                title: i18n.msg('chart.label.edit'),
                body: createModalContent(),
                classes: 'chart-edit-modal',
                buttons: [
                    // 미리보기
                    {
                        content: i18n.msg('chart.btn.preview'),
                        classes: "default-fill",
                        bindKey: false,
                        callback: function (modal) {
                        }
                    }],
                close: {
                    closable: false,
                },
                onCreate: function (modal) {
                    OverlayScrollbars(document.querySelector('.modal-content'), {className: 'scrollbar'});
                    getChart(chartId, 'edit');
                }
            };

            if (chartId !== undefined) {
                chartOptions.buttons.push({
                    content: i18n.msg('common.btn.delete'),
                    classes: "default-fill",
                    bindKey: false,
                    callback: function (modal) {
                        deleteChart(chartId);
                    }
                });
            }

            chartOptions.buttons.push({
                content: (chartId !== undefined) ? i18n.msg('common.btn.save') : i18n.msg('common.btn.register'),
                classes: "point-fill",
                bindKey: false,
                callback: function (modal) {
                    let method = (chartId !== undefined) ? 'put' : 'post'
                    saveChart(method, chartId)
                }
            });

            chartOptions.buttons.push({
                content: i18n.msg('common.btn.cancel'),
                classes: "default-line",
                bindKey: false,
                callback: function (modal) {
                    modal.hide();
                }
            });

            const chartEditModal = new modal(chartOptions);
            chartEditModal.show();
        }

        /**
         * Chart view 화면 호출 (Modal)
         */
        function openChartViewModal(chartId) {
            let chartOptions = {
                title: i18n.msg('chart.label.viewTitle'),
                body: createModalContent(),
                classes: 'chart-view-modal',
                buttons: [{
                    content: i18n.msg('common.btn.cancel'),
                    classes: "default-line",
                    bindKey: false,
                    callback: function (modal) {
                        modal.hide();
                    }
                }],
                close: {
                    closable: false,
                },
                onCreate: function (modal) {
                    getChart(chartId, 'view');
                }
            };

            const chartViewModal = new modal(chartOptions);
            chartViewModal.show();
        }

        function createModalContent() {
            return `<div class="flex-column" id="getChart"></div>`
        }

        function getChart(chartId, target) {
            let strUrl = ''
            if (chartId === undefined) {
                strUrl = '/charts/new';
            } else if (target === 'edit') {
                strUrl = '/charts/' + chartId + '/edit';
            } else {
                strUrl = '/charts/' + chartId + '/view';
            }

            const opt = {
                method: 'get',
                url: strUrl,
                contentType: 'application/json',
                showProgressbar: false,
                callbackFunc: function (response) {
                    if (target === 'edit' || target === 'view') {
                        document.getElementById('getChart').innerHTML = response.responseText;
                        if (target === 'edit') {
                            setDisplay(document.getElementById('typeSelectBox').value);
                        }
                        let data = parsedPropertyJson(document.getElementById('chartConfig').value, document.getElementById('propertyJson').value);
                        Highcharts.chart('container', data);
                    }
                }
            };
            aliceJs.sendXhr(opt);
        }

        function emptyValidataion() {
            if (isEmpty('chartName', 'chart.msg.enterChartName')) {
                return false
            }
            if (isEmpty('targetLabel', 'chart.msg.enterTargetLabel')) {
                return false
            }
            if (isEmpty('durationDigit', 'chart.msg.enterDurationDigit')) {
                return false
            }
            return true;
        }

        /**
         * chart 저장 / 수정
         */
        function saveChart(method, chartId) {
            if (emptyValidataion()) {
                let chartInfo = {
                    chartType: document.getElementById('typeSelectBox').value,
                    chartName: document.getElementById('chartName').value,
                    chartDesc: document.getElementById('chartDesc').value,
                    targetLabel: document.getElementById('targetLabel').value,
                    operation: document.getElementById('operationSelectBox').value,
                    durationDigit: document.getElementById('durationDigit').value,
                    durationUnit: document.getElementById('durationUnitSelectBox').value
                }

                if (chartInfo.chartType === STACKED_COLUMN_CHART || chartInfo.chartType === BASIC_LINE_CHART) {
                    chartInfo.periodUnit = document.getElementById('periodUnitSelectBox').value;

                    switch (chartInfo.durationUnit) {
                        case CHART_MONTH:
                            if (chartInfo.periodUnit === CHART_YEAR) {
                                aliceJs.alertDanger(i18n.msg('chart.msg.periodUnitOutOfRange'));
                                return false;
                            }
                            break;
                        case CHART_DAY:
                            if (chartInfo.periodUnit === CHART_YEAR || chartInfo.periodUnit === CHART_MONTH) {
                                aliceJs.alertDanger(i18n.msg('chart.msg.periodUnitOutOfRange'));
                                return false;
                            }
                            break;
                        case CHART_HOUR:
                            if (chartInfo.periodUnit === CHART_YEAR || chartInfo.periodUnit === CHART_MONTH || chartInfo.periodUnit === CHART_DAY) {
                                aliceJs.alertDanger(i18n.msg('chart.msg.periodUnitOutOfRange'));
                                return false;
                            }
                            break;
                    }

                    if (chartInfo.chartType === BASIC_LINE_CHART) {
                        chartInfo.group = document.getElementById('targetGroup').value;
                    }
                }

                let url = '/rest/charts';
                if (method === 'put' && chartId !== undefined) {
                    chartInfo.chartId = chartId;
                    url += '/' + chartId;
                }
                restSubmit(method, url, chartInfo, function (result) {
                    switch (result) {
                        case STATUS_SUCCESS:
                            aliceJs.alertSuccess(i18n.msg('common.msg.save'), function () {
                                location.reload()
                            });
                            break;
                        default:
                            aliceJs.alertDanger(i18n.msg('common.msg.fail'));
                            break;
                    }
                })
            }
        }

        /**
         * chart 삭제
         */
        function deleteChart(chartId) {
            aliceJs.confirmIcon(i18n.msg('common.msg.confirmDelete'), restSubmit, null, 'delete', '/rest/charts/' +
                chartId, {}, function (result) {
                switch (result) {
                    case STATUS_SUCCESS:
                        aliceJs.alertSuccess('[[#{common.msg.delete}]]', function () {
                            location.reload();
                        });
                        break;
                    default:
                        aliceJs.alertDanger(i18n.msg('common.msg.fail'));
                        break;
                }
            })
        }

        function onlyNumber(event) {
            event = event || window.event;
            const keyID = (event.which) ? event.which : event.keyCode;
            if (!((keyID >= 48 && keyID <= 57) || (keyID >= 96 && keyID <= 105)
                || keyID === 8 || keyID === 9 || keyID === 46 || keyID === 37 || keyID === 39)) {
                return false;
            }
        }

        function removeChar(event) {
            event = event || window.event;
            const keyID = (event.which) ? event.which : event.keyCode;
            if (!(keyID === 8 || keyID === 9 || keyID === 46 || keyID === 37 || keyID === 39)) {
                event.target.value = event.target.value.replace(/[^0-9]/g, '');
            }
        }

        function setDisplay(value) {
            if (value === BASIC_LINE_CHART || value === STACKED_COLUMN_CHART) {
                document.getElementById('periodUnitLabel').style.display = 'block';
                document.getElementById('periodUnitSelectBox').style.display = 'block';
                if (value === BASIC_LINE_CHART) {
                    document.getElementById('groupLabel').style.display = 'block';
                    document.getElementById('targetGroup').style.display = 'block';
                } else {
                    document.getElementById('groupLabel').style.display = 'none';
                    document.getElementById('targetGroup').style.display = 'none';
                }
            } else {
                document.getElementById('periodUnitLabel').style.display = 'none';
                document.getElementById('periodUnitSelectBox').style.display = 'none';
                document.getElementById('groupLabel').style.display = 'none';
                document.getElementById('targetGroup').style.display = 'none';
            }
        }

        /** chartConfig 파싱 진행 **/
        function parsedPropertyJson(chartConfig, property) {
            let chartConfigJson = JSON.parse(chartConfig);
            let propertyJson = JSON.parse(property);
            let jsonObject = new Object();

            // get chartConfigJson Data
            let type = chartConfigJson.type;
            let operation = chartConfigJson.operation;
            let durationDigit = chartConfigJson.duration.digit;
            let durationUnit = chartConfigJson.duration.unit;

            // get propertyJson Data
            let countArray = new Array;
            let percentArray = new Array;
            for (key in propertyJson[0].operation) {
                // 문서에 대한 카운트 개수
                countArray.push(propertyJson[0].operation[key].count);
                // 문서에 대한 각 퍼센트
                percentArray.push(propertyJson[0].operation[key].percent);
            }

            let docKeyList = new Array;
            let docValueList = new Array;
            for (key in propertyJson[1].documentList) {
                // 문서의 각 나눈 연도의 개수
                docKeyList.push(key);
                // 문서가 가진 정보 값 documentId, documentName, createDt
                docValueList.push(propertyJson[1].documentList[key]);
            }

            // Add ChartProperty
            if (chartConfigJson.type === PIE_CHART) {
                let chartProperty = new Object();
                chartProperty.type = 'pie';
                chartProperty.plotBackgroundColor = null;
                chartProperty.plotBorderWidth = null;
                chartProperty.plotShadow = false;
                jsonObject.chart = chartProperty;
            } else if (chartConfigJson.type === STACKED_COLUMN_CHART) {
                let chartProperty = new Object();
                chartProperty.type = 'column';
                jsonObject.chart = chartProperty;
            }

            // Add TitleProperty
            let titleProperty = new Object;
            titleProperty.text = propertyJson[0].title;
            jsonObject.title = titleProperty;

            // Add SubTitle
            if (chartConfigJson.type === BASIC_LINE_CHART) {
                let subTitleProperty = new Object;
                subTitleProperty.text = '통계 차트 보고서';
                jsonObject.subtitle = subTitleProperty;
            }

            // Add xAxisProperty
            if (chartConfigJson.type === STACKED_COLUMN_CHART || chartConfigJson.type === BASIC_LINE_CHART) {
                let xAxisProperty = new Object;
                xAxisProperty.type = 'datetime';
                jsonObject.xAxis = xAxisProperty;
            }

            // Add yAxisProperty
            if (chartConfigJson.type === STACKED_COLUMN_CHART) {
                let yAxisProperty = new Object;
                let yAxisTitleProperty = new Object;
                let stackedLabelsProperty = new Object;
                let styleProperty = new Object;
                yAxisProperty.min = 0;
                yAxisTitleProperty.text = 'Number of Document';
                yAxisProperty.title = yAxisTitleProperty;
                stackedLabelsProperty.enabled = true;
                styleProperty.fontWeight = 'bold';
                styleProperty.color = 'gray';
                stackedLabelsProperty.style = styleProperty;
                yAxisProperty.stackedLabels = stackedLabelsProperty;
                jsonObject.yAxis = yAxisProperty;
            } else if (chartConfigJson.type === BASIC_LINE_CHART) {
                let yAxisProperty = new Object;
                let yAxisTitleProperty = new Object;
                yAxisTitleProperty.text = 'Number of Documents';
                yAxisProperty.title = yAxisTitleProperty;
                jsonObject.yAxis = yAxisProperty;
            }

            // Add LegendProperty
            if (chartConfigJson.type === STACKED_COLUMN_CHART) {
                let legendProperty = new Object;
                legendProperty.align = 'right';
                legendProperty.x = -30;
                legendProperty.verticalAlign = 'top';
                legendProperty.y = 25;
                legendProperty.floating = true;
                legendProperty.backgroundColor = 'white';
                legendProperty.borderColor = '#CCC';
                legendProperty.borderWidth = 1;
                legendProperty.shadow = false;
                jsonObject.legend = legendProperty;
            } else if (chartConfigJson.type === BASIC_LINE_CHART) {
                let legendProperty = new Object;
                legendProperty.layout = 'vertical';
                legendProperty.align = 'right';
                legendProperty.verticalAlign = 'middle';
                jsonObject.legend = legendProperty;
            }

            // Add TooltipProperty
            if (chartConfigJson.type === PIE_CHART) {
                let tooltipProperty = new Object;
                if (chartConfigJson.operation === 'percent') {
                    tooltipProperty.pointFormat = '문서 차지 비율: <b>{point.percentage:.1f} %</b>';
                } else {
                    tooltipProperty.pointFormat = '문서 건 수: <b>{point.y:.f} 건</b>';
                }
                jsonObject.tooltip = tooltipProperty;
            } else if (chartConfigJson.type === STACKED_COLUMN_CHART) {
                let tooltipProperty = new Object;
                tooltipProperty.headerFormat = '<b>{point.x}</b><br/>';
                if (chartConfigJson.operation === 'percent') {
                    tooltipProperty.pointFormatter = function () {
                        let sum = countArray.reduce((a, b) => (a + b));
                        let percent = (this.y / sum) * 100;
                        return '문서 건 수: ' + '<b>' + Highcharts.numberFormat(percent) + '</b>' + '%';
                    }
                } else {
                    tooltipProperty.pointFormat = '문서 건 수: <b>{point.y:.f} 건</b>';
                }
                jsonObject.tooltip = tooltipProperty;
            }

            //Add AccessibilityProperty
            if (chartConfigJson.type === PIE_CHART) {
                let accessibilityProperty = new Object;
                let pointProperty = new Object;
                pointProperty.valueSuffix = '%';
                accessibilityProperty.point = pointProperty
                jsonObject.accessibility = accessibilityProperty;
            }

            // plotOptionsProperty
            let plotOptionsProperty = new Object;
            if (chartConfigJson.type === PIE_CHART) {
                let pieProperty = new Object;
                let dataLabelsProperty = new Object;
                pieProperty.allowPoinSelect = true;
                pieProperty.cursor = 'pointer';
                dataLabelsProperty.enabled = true;
                if (chartConfigJson.operation === 'percent') {
                    dataLabelsProperty.format = '<b>{point.name}</b>: {point.percentage:.1f} %';
                } else {
                    dataLabelsProperty.format = '<b>{point.name}</b>: {y:.f} 건';
                }
                pieProperty.dataLabels = dataLabelsProperty;
                plotOptionsProperty.pie = pieProperty;
            } else {
                const getYear = docKeyList[0].substring(0, 4);
                const getMonth = docKeyList[0].substring(4, 6);
                const getDay = docKeyList[0].substring(6, 8);
                const getHour = docKeyList[0].substring(8, 10);
                let seriesProperty = new Object;
                seriesProperty.pointStart = Date.UTC(getYear, getMonth, getDay, getHour);
                if (chartConfigJson.periodUnit === CHART_YEAR) {
                    seriesProperty.pointIntervalUnit = 'year';
                } else if (chartConfigJson.periodUnit === CHART_MONTH) {
                    seriesProperty.pointIntervalUnit = 'month';
                } else if (chartConfigJson.periodUnit === CHART_DAY) {
                    seriesProperty.pointIntervalUnit = 'day';
                } else {
                    seriesProperty.pointInterval = 3600 * 1000;
                }
                plotOptionsProperty.series = seriesProperty;

                if (chartConfigJson.type === STACKED_COLUMN_CHART) {
                    let columnProperty = new Object;
                    let dataLabelsProperty = new Object;
                    columnProperty.stacking = 'normal';
                    dataLabelsProperty.enabled = true;
                    if (chartConfigJson.operation === 'percent') {
                        dataLabelsProperty.formatter = function () {
                            let sum = countArray.reduce((a, b) => (a + b));
                            let percent = (this.y / sum) * 100;
                            return Highcharts.numberFormat(percent) + '%';
                        }
                    }
                    columnProperty.dataLabels = dataLabelsProperty;
                    plotOptionsProperty.column = columnProperty;
                }
            }
            jsonObject.plotOptions = plotOptionsProperty;

            // Add seriesProperty
            let seriesArray = new Array;
            let seriesObject = new Object;
            let seriesDataArray = new Array;
            if (chartConfigJson.type === PIE_CHART) {
                seriesObject.colorByPoint = true;
                for (let i = 0; i < Object.keys(propertyJson[1].documentList).length; i++) {
                    let seriesDataObject = new Object;
                    seriesDataObject.name = docKeyList[i];
                    seriesDataObject.y = countArray[i];
                    seriesDataObject.sliced = true;
                    seriesDataObject.selected = true;
                    seriesDataArray.push(seriesDataObject);
                    seriesObject.data = seriesDataArray;
                }
            } else if (chartConfigJson.type === STACKED_COLUMN_CHART) {
                seriesObject.name = 'Document'
                for (let i = 0; i < Object.keys(propertyJson[1].documentList).length; i++) {
                    seriesDataArray.push(countArray[i]);
                }
                seriesObject.data = seriesDataArray;
            } else if (chartConfigJson.type === BASIC_LINE_CHART) {
                seriesObject.name = 'Document';
                for (let i = 0; i < Object.keys(propertyJson[1].documentList).length; i++) {
                    seriesDataArray.push(countArray[i]);
                }
                seriesObject.data = seriesDataArray;
            }
            seriesArray.push(seriesObject);
            jsonObject.series = seriesArray;

            //Add responsiveProperty
            if (chartConfigJson.type === BASIC_LINE_CHART) {
                let responsiveProperty = new Object;
                let rulesArray = new Array;
                let rulesProperty = new Object;
                let conditionProperty = new Object;
                let chartOptionsProperty = new Object;
                let legendProperty = new Object;
                legendProperty.layout = 'horizontal';
                legendProperty.align = 'center';
                legendProperty.verticalAlign = 'bottom';
                chartOptionsProperty.legend = legendProperty;
                conditionProperty.maxWidth = 500;
                rulesProperty.condition = conditionProperty;
                rulesProperty.chartOptions = chartOptionsProperty;
                rulesArray.push(rulesProperty);
                responsiveProperty.rules = rulesArray;
                jsonObject.responsive = responsiveProperty;
            }

            console.log(jsonObject);
            return jsonObject;
        }

        /*]]>*/
    </script>
</th:block>
</html>
